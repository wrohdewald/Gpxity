#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Copyright (c) Wolfgang Rohdewald <wolfgang@rohdewald.de>
# See LICENSE for details.

# PYTHON_ARGCOMPLETE_OK
# for command line argument completion, put this into your .bashrc:
# eval "$(register-python-argcomplete gpxdo)"
# or see https://argcomplete.readthedocs.io/en/latest/


"""
gpxdo is a command line tool making use of the Gpxity library
"""


import argparse
import os
import sys
import datetime

try:
    import argcomplete
except ImportError:
    pass

# This uses not the installed copy but the development files
_ = os.path.dirname(sys.path[0] or sys.path[1])
if os.path.exists(os.path.join(_, 'gpxity', '__init__.py')):
    sys.path.insert(0, _)
# pylint: disable=wrong-import-position
from gpxity import Activity, Directory, BackendDiff, MMT, GPSIES
from gpxity.util import uniq


def valid_date_argument(arg_date_str):
    """custom argparse type for date as YYYY-MM-DD"""
    try:
        return datetime.datetime.strptime(arg_date_str, "%Y-%m-%d")
    except ValueError as exc:
        print(exc)
        msg = "Given Date ({0}) not valid! Expected format YYYY-MM-DD!".format(arg_date_str)
        raise argparse.ArgumentTypeError(msg)


class Utility:
    """this is where the work is done"""

    def __init__(self):
        self.exit_code = 0
        self.options = None
        self.parse_commandline()
        self.sources = []
        self.destination = None
        try:
            if self.options.source:
                objects = []
                for _ in self.options.source:
                    objects.append(self.instantiate_object(_))
                    # optimize the case where destination is also source
                    if hasattr(self.options, 'destination') and _ == self.options.destination:
                        self.destination = objects[-1]
                self.sources = self._collect_source_activities(objects)
            if hasattr(self.options, 'destination') and self.destination is None:
                self.destination = self.instantiate_object(self.options.destination)
                if self.options.func not in (self.diff, self.merge):
                    if isinstance(self.destination, Activity):
                        raise Exception('Destination must not be a single activity:{}'.format(self.options.destination))
                if not isinstance(self.destination, Activity) and self.options.verbose:
                    print('collecting activities from', self.destination.identifier())
            self.options.func()
        except Exception as _: # pylint: disable=broad-except
            self.error(_)

    def error(self, msg, exit_code=None):
        """Prints the error message.
        Sets the process exit code.
        With --debug, re-raises the exception."""
        print(msg)
        self.exit_code = exit_code or 1
        if self.options.debug:
            raise msg

    def _collect_source_activities(self, sources):
        """A copied list with activities combined from all sources, to be used in 'for'-loops"""
        result = list()
        for source in sources:
            if self.options.verbose:
                print('collecting activities from', source.identifier())
            if isinstance(source, Activity):
                result.append(source)
            else:
                result.extend(source)
        return result

    def move(self):
        """move gpx files.
        We cannot just do merge() followed by remove() because
        the source might have gotten new activities meanwhile, and
        they would disappear for good."""
        for _ in self.sources:
            self.destination.add(_, ident=_.id_in_backend)
            _.remove()
            if self.options.verbose:
                print('moved {} to {}'.format(_, self.destination))

    def remove(self):
        """remove activities"""
        for _ in self.sources:
            if self.options.dry_run:
                print('would remove {}'.format(_))
            else:
                _.remove()
                if self.options.verbose:
                    print('removed {}'.format(_))

    def list_them(self):
        """list activities"""
        header_line = list()
        sort_headers = list()
        output_lines = list()
        def add_field(condition, header, value):
            """Conditionally add value for the column named 'header'"""
            if condition:
                header_line.append(header)
                sort_headers.append(header.lower().strip())
                for idx, _ in enumerate(self.sources):
                    if idx == len(output_lines):
                        output_lines.append([])
                    output_lines[idx].append(value(_))

        add_field(True, 'Identifier', lambda x: x.identifier())
        add_field(self.options.title, 'Title', lambda x: x.title[:40]  if x.title else '')
        add_field(self.options.time, 'Time', lambda x: str(x.time))
        add_field(self.options.what, 'What', lambda x: x.what)
        add_field(self.options.keywords, 'Keywords', lambda x: ','.join(y for y in x.keywords))
        add_field(self.options.length, '    Length', lambda x: '{:>8.3f}km'.format(x.length()))
        add_field(self.options.points, 'Points', lambda x: '{:>6}'.format(x.gpx.get_track_points_no()))
        add_field(self.options.status, 'Status', lambda x: 'public' if x.public else 'private')
        add_field(self.options.description, 'Description', lambda x: x.description)

        if output_lines:
            sort_cols = self.options.sort.split(',')
            output_lines.sort(
                key=lambda x: ','.join('{:100}'.format(x[sort_headers.index(y)]) for y in sort_cols))
            output_lines.insert(0, header_line)
            field_lengths = list()
            for column in range(len(output_lines[0])):
                field_lengths.append(max(len(x[column]) for x in output_lines))
            for _ in output_lines:
                for idx, field in enumerate(_):
                    print('{field:{width}}'.format(width=field_lengths[idx], field=field), end='  ')
                print()

    @staticmethod
    def fix_activity(activity):
        """fix some bugs in the GPX file"""
        if isinstance(activity.backend, Directory):
            # make Directory build a new file name from the title
            activity._set_id_in_backend(None)  # pylint: disable=protected-access
        activity.rewrite()

    def fix(self):
        """fix activities"""
        for _ in self.sources:
            self.fix_activity(_)
            if self.options.verbose:
                print('fixed {}'.format(_))

    def keyword(self):
        """add/remove a single keyword"""
        kword = self.options.keyword
        for _ in self.sources:
            if self.options.remove:
                _.remove_keyword(kword)
                if self.options.verbose:
                    print('removed {} from {}'.format(kword, _))
            else:
                _.add_keyword(kword)
                if self.options.verbose:
                    print('added {} to {}'.format(kword, _))

    def merge(self):
        """Merge"""
        for activity in self.sources:
            msg = self.destination.merge(activity, remove=self.options.remove, dry_run=self.options.dry_run)
            if self.options.verbose or self.options.dry_run:
                for _ in msg:
                    print(_)

    def diff(self):
        """Compare"""
        # TODO: show all activities with backend name but only its last unique part
        def show_exclusive(side):
            """shows activities appearing only on one side."""
            backends = uniq(x.backend for x in side.exclusive)
            for backend in backends:
                print('only in {}:'.format(backend.url))
                for _ in side.exclusive:
                    if _.backend is backend:
                        print('    {}'.format(_))
                print()

        differ = BackendDiff(self.sources, self.destination)
        show_exclusive(differ.left)
        show_exclusive(differ.right)

        backend_pairs = uniq((x.left.backend, x.right.backend) for x in differ.similar)

        # pylint: disable=too-many-nested-blocks
        for left, right in backend_pairs:
            print('Differences between {} and {}'.format(left.url, right.url))
            for pair in differ.similar:
                if (pair.left.backend, pair.right.backend) == (left, right):
                    _ = ''.join(x if x in pair.differences else ' ' for x in BackendDiff.diff_flags)
                    print('-{}  {}'.format(_, pair.left))
                    print('+{}  {}'.format(_, pair.right))
                    for key, explain in pair.differences.items():
                        if explain:
                            _ = ''.join(x if x == key else ' ' for x in BackendDiff.diff_flags)
                            for explain_line in explain:
                                print(' {}  {}'.format(_, explain_line))
                    print()

    def instantiate_object(self, name):
        """returns a backend for name.
        If name is a single activity, the returned backend has a match filtering
        only this one wanted activity."""
        result = account = activity_id = None
        if ':' in name and name.split(':')[0].upper() in ('MMT', 'GPSIES'):
            clsname = name.split(':')[0].upper()
            rest = name[len(clsname) + 1:]
            if '/' in rest:
                if rest.count('/') > 1:
                    raise Exception('wrong syntax in {}'.format(name))
                account, activity_id = rest.split('/')
            else:
                account = rest
            if clsname == 'MMT':
                result = MMT(auth=account, timeout=self.options.timeout)
            elif clsname == 'GPSIES':
                result = GPSIES(auth=account, timeout=self.options.timeout)
        else:
            if os.path.isdir(name):
                account = name
                result = Directory(url=account)
            else:
                if name.endswith('.gpx'):
                    name = name[:-4]
                if os.path.isfile(name + '.gpx'):
                    account = os.path.dirname(name) or '.'
                    activity_id = os.path.basename(name)
                result = Directory(url=account)
        if account is None:
            raise Exception('{} not found'.format(name))
        if activity_id:
            result = result[activity_id]
        result.match = self.match
        result.debug = self.options.debug
        return result

    def match(self, activity):
        """Check against the selecting options. Does cheap check first."""
        # pylint: disable=too-many-return-statements
        if activity.time:
            if self.options.first_date and activity.time < self.options.first_date:
                return 'time {} is before {}'.format(activity.time, self.options.first_date)
            if self.options.last_date and activity.time > self.options.last_date:
                return 'time {} is after {}'.format(activity.time, self.options.last_date)
        length = activity.header_data.get('distance', None)
        if length:
            if self.options.min_length and length < self.options.min_length:
                return 'length {} is below {}'.format(length, self.options.min_length)
            if self.options.max_length and length > self.options.max_length:
                return 'length {} is above {}'.format(length, self.options.max_length)
        if self.options.min_points and activity.gpx.get_track_points_no() < self.options.min_points:
            return 'point count {} is below {}'.format(activity.gpx.get_track_points_no(), self.options.min_points)
        if self.options.max_points and activity.gpx.get_track_points_no() > self.options.max_points:
            return 'point count {} is above {}'.format(activity.gpx.get_track_points_no(), self.options.max_points)
        return None

    @staticmethod
    def add_range_args(parser):
        """Add common range arguments"""
        parser.add_argument('--first-date', help='Limit activities by date', type=valid_date_argument, default=None)
        parser.add_argument('--last-date', help='Limit activities by date', type=valid_date_argument, default=None)
        parser.add_argument('--min-points', help='Limit activities by minimum number of points', type=int, default=None)
        parser.add_argument('--max-points', help='Limit activities by maximum number of points', type=int, default=None)
        parser.add_argument('--min-length', help='Limit activities by track length', type=int, default=None)
        parser.add_argument('--max-length', help='Limit activities by track length', type=int, default=None)

    @staticmethod
    def add_common_args(parser):
        """Add the verbose argument"""
        parser.add_argument('--verbose', action='store_true', help='verbose output', default=False)
        parser.add_argument('--debug', action='store_true', help='debug backend traffic', default=False)
        parser.add_argument('--timeout', help="""
            Timeout: Either one value in seconds or two comma separated values: The first one is the connection timeout,
            the second one is the read timeout. Default is to wait forever.""", type=str, default=None)

    @staticmethod
    def add_multi_source(parser, must_have=False):
        """add --source for one or more activities or backends"""
        parser.add_argument('source', help='one ore more activities or backends', nargs='+' if must_have else '*')

    @staticmethod
    def add_destination(parser):
        """add --destination"""
        parser.add_argument('destination', help='the destination backend')

    help_epilog = """

source and destination arguments may be single
activities or entire backend instances.
Local files and directories are given as usual.
For all other backends, the syntax is:

backend:username  for all activities in a backend

or

backend:username/activity_id for one specific activity in a backend

Available backends are:

  - MMT     MapMytracks
  - GPSIES gpsies

The file $HOME/.config/Gpxity/auth.cfg
defines the type of the backend, username and password. Example:

[MMT:username]
Password = whatever

Dates are expected as YYYY-MM-DD.

"""

    def parse_commandline(self):
        """into self.options"""
        # pylint: disable=too-many-statements
        parser = argparse.ArgumentParser(
            'gpxdo', formatter_class=argparse.RawDescriptionHelpFormatter,
            epilog=self.help_epilog)
        subparsers = parser.add_subparsers()

        mv_parser = subparsers.add_parser(
            'mv', help='move sources to a destination backend',
            epilog=self.help_epilog, formatter_class=argparse.RawDescriptionHelpFormatter)
        mv_parser.set_defaults(func=self.move)
        self.add_common_args(mv_parser)
        self.add_range_args(mv_parser)
        self.add_multi_source(mv_parser)
        self.add_destination(mv_parser)

        rm_parser = subparsers.add_parser(
            'rm', help='remove activities',
            epilog=self.help_epilog, formatter_class=argparse.RawDescriptionHelpFormatter)
        rm_parser.set_defaults(func=self.remove)
        self.add_common_args(rm_parser)
        self.add_range_args(rm_parser)
        rm_parser.add_argument('--dry-run', help='only show what would be removed',
                               action='store_true', default=False)
        self.add_multi_source(rm_parser)

        if False: # pylint: disable=using-constant-test
            fix_parser = subparsers.add_parser(
                'fix', help='fix some GPX format bugs in activities',
                epilog=self.help_epilog, formatter_class=argparse.RawDescriptionHelpFormatter)
            fix_parser.set_defaults(func=self.fix)
            self.add_common_args(fix_parser)
            self.add_range_args(fix_parser)
            self.add_multi_source(fix_parser)

        ls_parser = subparsers.add_parser(
            'ls', help='list activities',
            epilog=self.help_epilog, formatter_class=argparse.RawDescriptionHelpFormatter)
        ls_parser.set_defaults(func=self.list_them)
        ls_parser.add_argument('--sort',
                               help="""one or more out of identifier,title,what,time,length,
                               points,keywords,status,
                               separated by commas (no spaces allowed)""",
                               default='identifier')
        ls_parser.add_argument('--long', help='show most useful info',
                               action='store_true', default=False)
        ls_parser.add_argument('--title', help='show the title',
                               action='store_true', default=False)
        ls_parser.add_argument('--what', help='show the activity type',
                               action='store_true', default=False)
        ls_parser.add_argument('--time', help='show the time',
                               action='store_true', default=False)
        ls_parser.add_argument('--length', help='show the length',
                               action='store_true', default=False)
        ls_parser.add_argument('--points', help='show the number of points',
                               action='store_true', default=False)
        ls_parser.add_argument('--status', help='show the status public/private',
                               action='store_true', default=False)
        ls_parser.add_argument('--keywords', help='show the keywords',
                               action='store_true', default=False)
        ls_parser.add_argument('--description', help='show the description',
                               action='store_true', default=False)
        self.add_common_args(ls_parser)
        self.add_range_args(ls_parser)
        self.add_multi_source(ls_parser)

        keyword_parser = subparsers.add_parser('kw', help='add or remove keywords')
        keyword_parser.set_defaults(func=self.keyword)
        self.add_common_args(keyword_parser)
        self.add_range_args(keyword_parser)
        keyword_parser.add_argument('--remove', help='remove keywords. Default is to add them.',
                                    action='store_true', default=False)
        keyword_parser.add_argument('keyword', help='a keyword')
        self.add_multi_source(keyword_parser)

        merge_parser = subparsers.add_parser(
            'merge', help="""
            merge activities: If their trackpoints are identical, add metadata like name,
            description or keywords from source to destination""",
            epilog=self.help_epilog, formatter_class=argparse.RawDescriptionHelpFormatter)
        merge_parser.set_defaults(func=self.merge)
        self.add_common_args(merge_parser)
        self.add_range_args(merge_parser)
        merge_parser.add_argument('--dry-run', help='only show what would change',
                                  action='store_true', default=False)
        merge_parser.add_argument('--remove', help='remove merged activities',
                                  action='store_true', default=False)
        self.add_multi_source(merge_parser)
        self.add_destination(merge_parser)

        diff_parser = subparsers.add_parser(
            'diff', help="""
            copmpare activities between source and destination""",
            epilog=self.help_epilog, formatter_class=argparse.RawDescriptionHelpFormatter)
        diff_parser.set_defaults(func=self.diff)
        self.add_common_args(diff_parser)
        self.add_range_args(diff_parser)
        self.add_multi_source(diff_parser, must_have=True)
        self.add_destination(diff_parser)


        try:
            argcomplete.autocomplete(parser)
        except NameError:
            pass

        if len(sys.argv) < 2:
            parser.print_usage()
            sys.exit(2)

        self.options = parser.parse_args()

        if self.options.timeout is not None:
            if ',' in self.options.timeout:
                self.options.timeout = tuple(float(x) for x in self.options.timeout.split(','))
            else:
                self.options.timeout = float(self.options.timeout)

        if self.options.func == self.list_them:
            if self.options.long:
                self.options.title = True
                self.options.time = True
                self.options.what = True
                self.options.keywords = True
                self.options.length = True
                self.options.status = True
            if not self.options.source:
                self.options.source = ['.']
        elif self.options.func == self.merge:
            if not self.options.source:
                self.options.source = [self.options.destination]

sys.exit(Utility().exit_code)
